<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOX BREAKER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #0ff;
            --secondary: #f0f;
            --accent: #ff0;
            --bg: #050510;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 0 0 10px var(--primary);
            font-size: 1.2rem;
            z-index: 10;
        }

        .hp-bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid white;
            background: rgba(0,0,0,0.5);
            transform: skewX(-20deg);
        }

        .hp-bar-fill {
            width: 100%;
            height: 100%;
            background: var(--secondary);
            box-shadow: 0 0 15px var(--secondary);
            transition: width 0.2s;
        }

        #screens {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .menu-box {
            text-align: center;
            color: white;
            animation: float 3s ease-in-out infinite;
        }

        h1 {
            font-size: 3rem;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,255,255,0.2);
            margin-bottom: 0;
        }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            margin-top: 20px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 15px var(--primary);
            transition: all 0.3s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        .btn:hover {
            background: var(--primary);
            color: black;
            transform: scale(1.05);
        }

        .hidden { display: none !important; }

        .leaderboard {
            margin-top: 20px;
            text-align: left;
            background: rgba(0,0,0,0.6);
            padding: 20px;
            border: 1px solid var(--accent);
            max-height: 200px;
            overflow-y: auto;
        }

        .lb-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #ddd;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Mobile Controls Hints */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 50px;
            width: 100%;
            justify-content: space-between;
            padding: 0 50px;
            box-sizing: border-box;
            opacity: 0.3;
        }
        @media (hover: none) and (pointer: coarse) {
            .mobile-controls { display: flex; }
            h1 { font-size: 2rem; }
            .control-circle {
                width: 80px; /* Larger touch targets */
                height: 80px;
                font-size: 12px;
            }
        }
        .control-circle {
            width: 60px;
            height: 60px;
            border: 2px dashed white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
        }

        /* Multiplayer UI */
        .mp-panel {
            margin-top: 20px;
            text-align: left;
            background: rgba(0,0,0,0.6);
            padding: 12px;
            border: 1px solid var(--primary);
            max-width: 480px;
            margin-left: auto;
            margin-right: auto;
            border-radius: 6px;
        }
        .mp-row {
            display:flex;
            gap:8px;
            margin-top:8px;
            flex-wrap:wrap;
        }
        .qr {
            margin-top: 12px;
        }
        .mono {
            font-family: monospace;
            font-size: 0.9rem;
            color: #0ff;
            word-break: break-all;
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score">SCORE: 0</div>
            <div class="hp-bar-container"><div class="hp-bar-fill" id="hpBar"></div></div>
        </div>
        <div class="mobile-controls">
            <div class="control-circle">DRAG MOVE</div>
            <div class="control-circle">TAP SHOOT</div>
        </div>
    </div>

    <div id="screens">
        <div class="menu-box" id="startScreen">
            <h1>NEON FRAGMENT</h1>
            <p>Destroy Purple Boxes for Chain Reactions</p>
            <p>WASD/Touch to Move | Click/Tap to Shoot</p>
            <div class="mp-row">
                <button class="btn" onclick="showSingle()">INITIATE</button>
                <button class="btn" onclick="showMultiplayer()">MULTIPLAYER</button>
            </div>
        </div>

        <div class="menu-box hidden" id="mpScreen">
            <h1>MULTIPLAYER</h1>
            <p>Host or Join a session. Host creates an invite (link/QR). Joiners open it and share the answer back to the Host (QR or paste).</p>

            <div class="mp-panel" id="mpPanel">
                <div class="mp-row">
                    <button class="btn" onclick="startHost()">Host Session</button>
                    <button class="btn" onclick="prepareJoin()">Join Session</button>
                    <button class="btn" onclick="backToMain()">Back</button>
                </div>

                <div id="hostArea" class="" style="display:none;">
                    <h3>Host Controls</h3>
                    <div id="inviteInfo"></div>
                    <div id="inviteQR" class="qr"></div>
                    <div style="margin-top:10px;">
                        <label class="mono">Paste Answer from joiner:</label>
                        <textarea id="answerPaste" style="width:100%;height:80px;background:#000;color:#0ff;border:1px solid #0ff;"></textarea>
                        <div class="mp-row" style="margin-top:8px;">
                            <button class="btn" onclick="applyAnswer()">Apply Answer</button>
                            <button class="btn" onclick="createInvite()">Create Another Invite</button>
                        </div>
                    </div>
                    <div id="connections" style="margin-top:12px;color:#ddd;"></div>
                </div>

                <div id="joinArea" style="display:none;">
                    <h3>Join Controls</h3>
                    <div id="offerInfo"></div>
                    <div style="margin-top:8px;">
                        <label class="mono">If you opened an invite link, it will be detected and an Answer will be generated. Copy/QR it to give to the Host.</label>
                    </div>
                    <div id="answerOut" style="margin-top:10px;"></div>
                    <div style="margin-top:8px;">
                        <label class="mono">Or paste an Offer here (if host gave you offer text):</label>
                        <textarea id="offerPaste" style="width:100%;height:80px;background:#000;color:#0ff;border:1px solid #0ff;"></textarea>
                        <div class="mp-row" style="margin-top:8px;">
                            <button class="btn" onclick="createAnswerFromPaste()">Create Answer</button>
                        </div>
                    </div>
                </div>

            </div>

        </div>

        <div class="menu-box hidden" id="gameOverScreen">
            <h1>SYSTEM FAILURE</h1>
            <h2 id="finalScore">Score: 0</h2>
            <div class="leaderboard" id="leaderboardContent"></div>
            <button class="btn" onclick="startGame()">REBOOT</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * Multiplayer additions summary:
 * - Manual WebRTC signaling via offer/answer that can be shared as text or QR code.
 * - Host is authoritative: game state runs on host and is broadcast to connected peers via DataChannels.
 * - Clients send only inputs (movement/shot) to host; host applies inputs to remote players and includes remote players in the authoritative simulation.
 * - No external signaling server required â€” invites are encoded into links (hash) that contain base64 SDP. For the final handshake, the joining player creates an Answer and shares it back to the Host (paste/QR).
 *
 * Notes/limitations:
 * - This is a front-end-only peer system using manual exchange (host creates invites, joiner opens them and returns answers).
 * - Host must accept the answer by pasting/scanning it into the Host UI.
 * - Multiple players: Host creates a separate invite for each joiner (press "Create Another Invite").
 */

/**
 * AUDIO ENGINE (Synthesizer)
 * Generates sounds on the fly using Web Audio API to keep file size small.
 */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        // Pitch drop for effect
        osc.frequency.exponentialRampToValueAtTime(freq * 0.1, this.ctx.currentTime + duration);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot() { this.playTone(600, 'sawtooth', 0.1, 0.05); },
    hit() { this.playTone(200, 'square', 0.1, 0.1); },
    explode() { 
        // Noise buffer for explosion
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    powerup() { 
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(440, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(880, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
};

/**
 * GAME CONSTANTS & SETUP
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input State
const input = {
    keys: {},
    mouse: { x: 0, y: 0, down: false },
    touch: { active: false, startX: 0, startY: 0, currX: 0, currY: 0, joystickActive: false, id: null }
};

// Event Listeners
window.addEventListener('keydown', e => input.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => { input.mouse.x = e.clientX; input.mouse.y = e.clientY; });
window.addEventListener('mousedown', () => input.mouse.down = true);
window.addEventListener('mouseup', () => input.mouse.down = false);

// Touch Handling (Multi-touch support for Twin Stick feel)
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        if (t.clientX < width / 2 && !input.touch.joystickActive) { // Assign joystick if left side and not active
            input.touch.joystickActive = true;
            input.touch.startX = t.clientX;
            input.touch.startY = t.clientY;
            input.touch.currX = t.clientX;
            input.touch.currY = t.clientY;
            input.touch.id = t.identifier;
        } else if (t.clientX >= width / 2) { // Right side: Shoot
            input.mouse.down = true;
            input.mouse.x = t.clientX;
            input.mouse.y = t.clientY;
        }
    }
}, {passive: false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i = 0; i < e.touches.length; i++) {
        const t = e.touches[i];
        if (input.touch.joystickActive && t.identifier === input.touch.id) {
            input.touch.currX = t.clientX;
            input.touch.currY = t.clientY;
        } else if (t.clientX >= width / 2) {
            input.mouse.x = t.clientX;
            input.mouse.y = t.clientY;
        }
    }
}, {passive: false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    let joystickStillActive = false;
    let shootingStillActive = false;

    // Check if the joystick touch is still active
    for (let i = 0; i < e.touches.length; i++) {
        if (e.touches[i].identifier === input.touch.id) {
            joystickStillActive = true;
        }
        if (e.touches[i].clientX >= width / 2) {
            shootingStillActive = true;
        }
    }

    if (!joystickStillActive) {
        input.touch.joystickActive = false;
        input.touch.id = null; // Clear ID
    }
    
    input.mouse.down = shootingStillActive; // Stop shooting if no right-side touches left
}, {passive: false});


/**
 * UTILS
 */
const rand = (min, max) => Math.random() * (max - min) + min;
const checkCircleRect = (circle, rect) => {
    let distX = Math.abs(circle.x - rect.x - rect.w / 2);
    let distY = Math.abs(circle.y - rect.y - rect.h / 2);
    if (distX > (rect.w / 2 + circle.r)) return false;
    if (distY > (rect.h / 2 + circle.r)) return false;
    if (distX <= (rect.w / 2)) return true;
    if (distY <= (rect.h / 2)) return true;
    let dx = distX - rect.w / 2;
    let dy = distY - rect.h / 2;
    return (dx * dx + dy * dy <= (circle.r * circle.r));
};
const vibrate = (ms) => {
    if (navigator.vibrate) navigator.vibrate(ms);
};

function sdpToBase64(sdp) {
    return btoa(unescape(encodeURIComponent(sdp)));
}
function base64ToSdp(b64) {
    return decodeURIComponent(escape(atob(b64)));
}
function shortId() {
    return Math.random().toString(36).slice(2,9);
}

/**
 * GAME OBJECTS
 */

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.alpha = 1;
        this.decay = rand(0.01, 0.03);
        this.size = rand(1, 4);
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= this.decay;
        this.size *= 0.95;
    }
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, angle, type = 'normal') {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * 15;
        this.vy = Math.sin(angle) * 15;
        this.r = 4;
        this.dead = false;
        this.type = type; // normal, blast
        this.color = '#fff';
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.dead = true;
    }
    draw(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Box {
    constructor(x, y) {
        this.w = 40;
        this.h = 40;
        this.x = x;
        this.y = y;
        // Types: 0=Standard, 1=Hard, 2=Explosive(Puzzle)
        this.type = Math.random() > 0.9 ? 2 : (Math.random() > 0.7 ? 1 : 0);
        this.hp = this.type === 1 ? 5 : (this.type === 2 ? 1 : 2);
        this.dead = false;
        
        // Visuals
        this.color = this.type === 2 ? '#d0f' : (this.type === 1 ? '#fa0' : '#0ff');
        this.pulse = 0;
    }
    draw(ctx) {
        this.pulse += 0.1;
        const glow = Math.sin(this.pulse) * 10 + 10;
        ctx.shadowBlur = glow;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        
        // Fill based on HP
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = this.color;
        const initialMaxHp = this.type === 1 ? 5 : (this.type === 2 ? 1 : 2);
        const fillH = (this.hp / initialMaxHp) * this.h;
        ctx.fillRect(this.x, this.y + (this.h - fillH), this.w, fillH);
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;

        if (this.type === 2) {
            ctx.fillStyle = '#fff';
            ctx.font = '20px Orbitron';
            ctx.fillText('!', this.x + 15, this.y + 28);
        }
    }
}

class Enemy {
    constructor(player, baseSpeed) {
        const side = Math.floor(Math.random() * 4);
        if (side === 0) { this.x = rand(0, width); this.y = -50; }
        else if (side === 1) { this.x = width + 50; this.y = rand(0, height); }
        else if (side === 2) { this.x = rand(0, width); this.y = height + 50; }
        else { this.x = -50; this.y = rand(0, height); }

        this.player = player;
        this.r = 15;
        this.speed = baseSpeed * rand(0.8, 1.2); // Apply some variation to base speed
        this.hp = 3;
        this.dead = false;
        this.color = '#f00';
    }
    update() {
        const angle = Math.atan2(this.player.y - this.y, this.player.x - this.x);
        this.x += Math.cos(angle) * this.speed;
        this.y += Math.sin(angle) * this.speed;
        
        // Wobble
        this.x += Math.sin(Date.now() / 100) * 0.5;
    }
    draw(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Triangle shape
        ctx.moveTo(this.x + Math.cos(0)*this.r, this.y + Math.sin(0)*this.r);
        ctx.lineTo(this.x + Math.cos(2.09)*this.r, this.y + Math.sin(2.09)*this.r);
        ctx.lineTo(this.x + Math.cos(4.18)*this.r, this.y + Math.sin(4.18)*this.r);
        ctx.closePath();
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

class Powerup {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.r = 10;
        this.type = Math.random() > 0.5 ? 'hp' : 'tri'; // hp = Heal, tri = Triple Shot
        this.dead = false;
    }
    draw(ctx) {
        const color = this.type === 'hp' ? '#0f0' : '#ff0';
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.type === 'hp' ? '+' : 'W', this.x, this.y);
        ctx.shadowBlur = 0;
    }
}

class Player {
    constructor() {
        this.x = width / 2;
        this.y = height / 2;
        this.r = 15;
        this.color = '#0ff';
        this.speed = 6; // Slightly faster player base speed
        this.maxHp = 100;
        this.hp = 100;
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.9;
        this.cooldown = 0;
        this.fireRate = 8; // Faster firing rate (lower cooldown)
        this.weapon = 1; // 1 = Single, 3 = Triple
        this.weaponTimer = 0;
        this.touchMoveMultiplier = 1.5; // Boost touch joystick movement
    }
    updateFromInput(localInput) {
        // Called for host-controlled players (including host's own player)
        // Movement
        let dx = 0;
        let dy = 0;

        if (localInput.keys && (localInput.keys['w'] || localInput.keys['arrowup'])) dy = -1;
        if (localInput.keys && (localInput.keys['s'] || localInput.keys['arrowdown'])) dy = 1;
        if (localInput.keys && (localInput.keys['a'] || localInput.keys['arrowleft'])) dx = -1;
        if (localInput.keys && (localInput.keys['d'] || localInput.keys['arrowright'])) dx = 1;

        // Touch joystick fields for remote inputs might supply moveX/moveY
        if (typeof localInput.moveX === 'number' || typeof localInput.moveY === 'number') {
            if (Math.abs(localInput.moveX) > 0.001 || Math.abs(localInput.moveY) > 0.001) {
                dx = localInput.moveX;
                dy = localInput.moveY;
            }
        }

        if (dx !== 0 || dy !== 0) {
            this.vx += dx * 0.8;
            this.vy += dy * 0.8;
        }

        // Apply Friction
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Cap speed
        const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        if (speed > this.speed) {
            const angle = Math.atan2(this.vy, this.vx);
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        }

        this.x += this.vx;
        this.y += this.vy;

        // Bounds
        this.x = Math.max(this.r, Math.min(width - this.r, this.x));
        this.y = Math.max(this.r, Math.min(height - this.r, this.y));

        // Weapons Timer
        if (this.weapon > 1) {
            this.weaponTimer--;
            if (this.weaponTimer <= 0) this.weapon = 1;
        }
    }
    draw(ctx) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        // Inner core
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

/**
 * MULTIPLAYER STATE
 */
let isHost = false;
let isClient = false;
let peers = {}; // inviteId -> {pc,dc,connected,remoteId}
let remoteInputs = {}; // clientId -> latest input object (for host)
let remotePlayers = {}; // clientId -> Player instance (host authoritative)
let clientId = null; // this client's id (if client)
let hostInviteId = null; // current invite id (host-side)
let broadcastInterval = null;

/**
 * WebRTC helpers (manual invite flow)
 */
const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

async function createInvite() {
    // Host creates a PeerConnection and DataChannel, makes an offer, and encodes it into a link
    const invite = shortId();
    hostInviteId = invite;
    const pc = new RTCPeerConnection(rtcConfig);
    const dc = pc.createDataChannel('game', { ordered: true });

    peers[invite] = { pc, dc, connected: false, remoteClientId: null };

    dc.onopen = () => {
        peers[invite].connected = true;
        updateConnectionsUI();
    };
    dc.onmessage = ev => {
        handleClientMessage(invite, ev.data);
    };

    pc.onicecandidate = e => {
        // Wait until complete gathering OR send progressive candidates via the same manual flow
        // For simplicity we wait for complete gathering by watching pc.localDescription.sdp when all candidates done.
        // Some browsers provide trickle ICE; we still produce the SDP and the joiner will setRemoteDescription and create answer with their ICE candidates.
        // Note: this manual approach works best when both sides can gather ICE candidates before exchanging.
    };

    // create offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    // Wait briefly for ICE candidates to be gathered (not perfect but helps)
    await new Promise(resolve => setTimeout(resolve, 700));

    const sdp = pc.localDescription.sdp;
    const b64 = sdpToBase64(sdp);
    const inviteLink = window.location.href.split('#')[0] + `#invite=${invite}&offer=${b64}`;

    // Show invite link + QR
    const inviteInfo = document.getElementById('inviteInfo');
    inviteInfo.innerHTML = `<div class="mono">Invite ID: ${invite}</div><div class="mono" style="margin-top:6px">Invite Link (share or scan QR):</div><div class="mono">${inviteLink}</div>`;

    // Use free QR API to show QR (works with encoded data)
    const qrImg = document.getElementById('inviteQR');
    qrImg.innerHTML = `<img src="https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=${encodeURIComponent(inviteLink)}" alt="QR">`;

    updateConnectionsUI();
    return invite;
}

async function applyAnswer() {
    // Host pastes answer into textarea; we'll match it to the latest invite id (or pick one)
    const txt = document.getElementById('answerPaste').value.trim();
    if (!txt) return alert('Paste the Answer (base64 SDP) from the joiner.');
    // the answer should be in format invite=ID&answer=BASE64 or simply BASE64. Support both.
    let answerB64 = txt;
    let matchedInvite = hostInviteId;
    // If user pasted a URL/hash with invite key:
    if (txt.includes('invite=') && txt.includes('answer=')) {
        try {
            const params = {};
            txt.split('#')[1].split('&').forEach(p => {
                const [k,v] = p.split('=');
                params[k]=v;
            });
            if (params.invite) matchedInvite = params.invite;
            if (params.answer) answerB64 = params.answer;
        } catch(e){}
    } else if (txt.includes('answer=')) {
        try {
            answerB64 = txt.split('answer=')[1];
        } catch(e){}
    }

    if (!matchedInvite || !peers[matchedInvite]) {
        // try to find any peer that isn't connected yet
        const candidate = Object.keys(peers).find(k => !peers[k].connected);
        if (candidate) matchedInvite = candidate;
        else return alert('No matching invite found. Create an invite first.');
    }

    const pc = peers[matchedInvite].pc;
    try {
        const sdp = base64ToSdp(answerB64);
        await pc.setRemoteDescription({ type: 'answer', sdp });
        // mark connected; DataChannel onopen will set connected flag
        updateConnectionsUI();
        document.getElementById('answerPaste').value = '';
    } catch(e) {
        console.error(e);
        alert('Failed to apply answer. Ensure the pasted answer is correct and complete.');
    }
}

function handleClientMessage(inviteId, raw) {
    // Called on Host when a client sends messages
    try {
        const msg = JSON.parse(raw);
        if (!msg.type) return;
        if (msg.type === 'join') {
            // register client id; create remote player
            const client = msg.id || shortId();
            peers[inviteId].remoteClientId = client;
            remoteInputs[client] = {}; // init
            // create remote player at requested spawn or near host player
            const spawnX = (msg.spawn && msg.spawn.x) ? msg.spawn.x * width : player.x + rand(-50,50);
            const spawnY = (msg.spawn && msg.spawn.y) ? msg.spawn.y * height : player.y + rand(-50,50);
            const p = new Player();
            p.x = spawnX;
            p.y = spawnY;
            p.color = '#'+(Math.random()*0xFFFFFF<<0).toString(16).padStart(6,'0');
            remotePlayers[client] = p;
            updateConnectionsUI();
        } else if (msg.type === 'input') {
            if (msg.id) remoteInputs[msg.id] = msg;
            else console.warn('input without id');
        }
    } catch(e) {
        console.warn('non-json message', raw);
    }
}

/**
 * Joiner flow: when a visitor opens a link with offer in hash, create an answer and show it for host.
 */
async function prepareJoin() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('mpScreen').classList.remove('hidden');

    document.getElementById('hostArea').style.display = 'none';
    document.getElementById('joinArea').style.display = 'block';
}

async function createAnswerFromOffer(inviteId, offerB64) {
    // Joins an offer provided in the URL
    const sdp = base64ToSdp(offerB64);
    const pc = new RTCPeerConnection(rtcConfig);

    clientId = shortId();

    pc.ondatachannel = ev => {
        const dc = ev.channel;
        dc.onopen = () => {
            isClient = true;
            // join by sending join message
            const joinMsg = { type:'join', id: clientId, spawn: { x: 0.5, y: 0.5 } };
            dc.send(JSON.stringify(joinMsg));
            // start sending inputs periodically on animation frame
        };
        dc.onmessage = msgEv => {
            try {
                const data = JSON.parse(msgEv.data);
                if (data.type === 'state') {
                    applyStateFromHost(data);
                }
            } catch(e) {
                // ignore
            }
        };
        // save to window for sending input
        window._clientDC = dc;
    };

    await pc.setRemoteDescription({ type:'offer', sdp });
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    // Wait a bit for ICE
    await new Promise(r => setTimeout(r, 700));

    const answerB64 = sdpToBase64(pc.localDescription.sdp);

    // Provide answer text and a QR (so host can scan OR paste)
    const ansOut = document.getElementById('answerOut');
    ansOut.innerHTML = `<div class="mono">Answer (give to Host):</div><textarea readonly style="width:100%;height:80px;background:#000;color:#0ff;border:1px solid #0ff;">${answerB64}</textarea>
        <div class="qr"><img src="https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=${encodeURIComponent(window.location.href.split('#')[0] + '#answer=' + answerB64)}" alt="QR"></div>`;

    // Also offer a combined string with invite & answer for easier paste
    const combined = `invite=${inviteId}&answer=${answerB64}`;
    ansOut.innerHTML += `<div style="margin-top:8px;"><div class="mono">Combined (quick paste for Host):</div><textarea readonly style="width:100%;height:50px;background:#000;color:#0ff;border:1px solid #0ff;">${combined}</textarea></div>`;

    // Keep PC alive
    window._clientPC = pc;
    document.getElementById('offerInfo').innerText = `Prepared Answer for invite ${inviteId}.`;
}

function createAnswerFromPaste() {
    const txt = document.getElementById('offerPaste').value.trim();
    if (!txt) return alert('Paste the offer text (base64 offer or url/hash that includes offer=...)');
    // try to parse
    let offerB64 = txt;
    if (txt.includes('offer=')) {
        try {
            offerB64 = txt.split('offer=')[1].split('&')[0];
        } catch(e){}
    }
    // If the user pasted the full invite link (they may have)
    if (txt.includes('#') && txt.includes('offer=')) {
        try {
            const after = txt.split('#')[1];
            const params = {};
            after.split('&').forEach(p => { const [k,v]=p.split('='); params[k]=v; });
            if (params.offer && params.invite) {
                offerB64 = params.offer;
                createAnswerFromOffer(params.invite, offerB64);
                return;
            }
        } catch(e){}
    }
    // No invite id in paste: create answer but host will need to indicate which invite it belongs to
    createAnswerFromOffer('unknown', offerB64);
}

/**
 * Host UI helpers
 */
function updateConnectionsUI() {
    const c = document.getElementById('connections');
    const lines = [];
    for (const k of Object.keys(peers)) {
        lines.push(`<div class="mono">Invite: ${k} | connected: ${peers[k].connected} | clientId: ${peers[k].remoteClientId || '-'}</div>`);
    }
    c.innerHTML = lines.join('');
}

/**
 * Detect incoming invite when the page is loaded with a hash containing invite & offer
 */
window.addEventListener('load', () => {
    const hash = window.location.hash.slice(1);
    if (!hash) {
        updateLeaderboard(0); // initial leaderboard load
        return;
    }
    const params = {};
    hash.split('&').forEach(p => {
        const [k,v] = p.split('=');
        params[k]=v;
    });
    if (params.invite && params.offer) {
        // We're a joiner opening a host invite link
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('mpScreen').classList.remove('hidden');
        document.getElementById('hostArea').style.display = 'none';
        document.getElementById('joinArea').style.display = 'block';
        prepareJoin();
        createAnswerFromOffer(params.invite, params.offer).catch(e => console.error(e));
    } else if (params.answer) {
        // Someone pasted an answer via link - this can be used by host when they open a combined link
        // Put it into answerPaste for convenience
        document.getElementById('answerPaste').value = params.answer;
    }

    // Also load leaderboard when page is opened normally
    if (!params.invite) updateLeaderboard(0);
});

/**
 * When acting as host, broadcast authoritative game state to all peers periodically.
 */
function startBroadcastingState() {
    if (broadcastInterval) clearInterval(broadcastInterval);
    broadcastInterval = setInterval(() => {
        const state = {
            type: 'state',
            score,
            players: [], // include host player + remote players
            bullets: bullets.map(b => ({x:b.x,y:b.y,vx:b.vx,vy:b.vy,r:b.r,color:b.color})),
            boxes: boxes.map(b => ({x:b.x,y:b.y,w:b.w,h:b.h,hp:b.hp,type:b.type,color:b.color})),
            enemies: enemies.map(e => ({x:e.x,y:e.y,hp:e.hp,color:e.color})),
            powerups: powerups.map(p => ({x:p.x,y:p.y,type:p.type}))
        };
        // players
        // host player is always included
        state.players.push({id: 'host', x: player.x, y: player.y, hp: player.hp, color: player.color, weapon: player.weapon});
        for (const id of Object.keys(remotePlayers)) {
            const rp = remotePlayers[id];
            state.players.push({id, x: rp.x, y: rp.y, hp: rp.hp, color: rp.color, weapon: rp.weapon});
        }

        const s = JSON.stringify(state);
        for (const k of Object.keys(peers)) {
            const entry = peers[k];
            if (entry.dc && entry.dc.readyState === 'open') {
                try { entry.dc.send(s); } catch(e) { /* ignore send errors */ }
            }
        }
    }, 1000/15); // 15 Hz
}

function stopBroadcasting() {
    if (broadcastInterval) clearInterval(broadcastInterval);
    broadcastInterval = null;
}

/**
 * Host: create peer & invite UI
 */
async function startHost() {
    isHost = true;
    isClient = false;
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('mpScreen').classList.remove('hidden');

    document.getElementById('hostArea').style.display = 'block';
    document.getElementById('joinArea').style.display = 'none';

    await createInvite();
    startBroadcastingState();
}

/**
 * Client: Join flow from UI (manual paste)
 */
function startClientGame() {
    // Called after we've established DataChannel and are receiving states
    isClient = true;
    isHost = false;

    // Hide screens and go to game view
    document.getElementById('screens').classList.add('hidden');
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('mpScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');

    AudioSys.init(); // ensure audio unlocked
    // clients will rely on states coming from host
    loop();
}

/**
 * Called by client when a 'state' message is received from host
 */
function applyStateFromHost(state) {
    // Overwrite local arrays with authoritative ones
    score = state.score || score;

    // Rebuild boxes, bullets, enemies, powerups using constructors so draw() can reuse
    boxes = (state.boxes || []).map(b => {
        const bo = new Box(b.x, b.y);
        bo.w = b.w; bo.h = b.h; bo.hp = b.hp; bo.type = b.type; bo.color = b.color;
        return bo;
    });
    bullets = (state.bullets || []).map(b => {
        const bl = new Bullet(b.x, b.y, 0);
        bl.vx = b.vx; bl.vy = b.vy; bl.r = b.r; bl.color = b.color;
        return bl;
    });
    enemies = (state.enemies || []).map(e => {
        const en = new Enemy({x: width/2, y: height/2}, enemyBaseSpeed);
        en.x = e.x; en.y = e.y; en.hp = e.hp; en.color = e.color;
        return en;
    });
    powerups = (state.powerups || []).map(p => {
        const pu = new Powerup(p.x, p.y);
        pu.type = p.type;
        return pu;
    });

    // Players array: update local player and remote player representations
    // Ensure we have a Player instance for ourselves and for other players
    const playersArr = state.players || [];
    // find my player id if known
    for (const p of playersArr) {
        if (p.id === clientId) {
            // ensure player exists
            if (!player) player = new Player();
            player.x = p.x; player.y = p.y; player.hp = p.hp;
        } else if (p.id === 'host') {
            // represent host as another remote (if needed)
            let idp = 'host';
            if (!remotePlayers[idp]) {
                const pr = new Player();
                pr.x = p.x; pr.y = p.y; pr.color = p.color || '#0ff';
                remotePlayers[idp] = pr;
            } else {
                remotePlayers[idp].x = p.x; remotePlayers[idp].y = p.y; remotePlayers[idp].hp = p.hp;
            }
        } else {
            if (!remotePlayers[p.id]) {
                const pr = new Player();
                pr.x = p.x; pr.y = p.y; pr.color = p.color || '#0ff';
                remotePlayers[p.id] = pr;
            } else {
                remotePlayers[p.id].x = p.x; remotePlayers[p.id].y = p.y; remotePlayers[p.id].hp = p.hp;
            }
        }
    }

    // Start client loop if not already running
    if (!isClient) {
        startClientGame();
    }
}

/**
 * Host side: apply remote inputs to remotePlayers
 * - remoteInputs[clientId] should contain { moveX, moveY, aimX, aimY, shooting, id }
 * - We'll create bullets on host when shooting events are received
 */
function processRemoteInputs() {
    for (const id of Object.keys(remoteInputs)) {
        const inp = remoteInputs[id];
        if (!remotePlayers[id]) continue;
        const rp = remotePlayers[id];

        // Build a simplified localInput object used to update Player
        const localInput = { keys: inp.keys || {}, moveX: inp.moveX, moveY: inp.moveY };
        rp.updateFromInput(localInput);

        // Shooting
        if (inp.shooting && inp.shooting === true) {
            // Respect fire rate by tracking a cooldown on rp
            if (!rp.cooldown) rp.cooldown = 0;
            if (rp.cooldown <= 0) {
                // Use aim vector to compute angle if provided, otherwise default forward
                let angle = 0;
                if (typeof inp.aimX === 'number' && typeof inp.aimY === 'number') {
                    angle = Math.atan2(inp.aimY, inp.aimX);
                } else {
                    angle = 0;
                }
                bullets.push(new Bullet(rp.x, rp.y, angle));
                if (rp.weapon === 3) {
                    bullets.push(new Bullet(rp.x, rp.y, angle - 0.2));
                    bullets.push(new Bullet(rp.x, rp.y, angle + 0.2));
                }
                rp.cooldown = rp.fireRate || 8;
                AudioSys.shoot();
            } else {
                rp.cooldown--;
            }
        }
    }
}

/**
 * MAIN GAME LOOP
 */
let gameLoopId;
let score = 0;
let frame = 0;
let player;
let bullets = [];
let particles = [];
let boxes = [];
let enemies = [];
let powerups = [];

// Difficulty Variables
let enemyBaseSpeed = 1;
let enemySpawnFrequency = 240; // Frames per enemy spawn (240 frames = 4 seconds at 60fps)
let maxActiveBoxes = 5; // Initial max boxes

function spawnBox() {
    // Attempt to spawn without overlapping player
    for(let i=0; i<5; i++) {
        const x = rand(50, width - 90);
        const y = rand(50, height - 90);
        const dist = Math.sqrt((x-player.x)**2 + (y-player.y)**2);
        if(dist > 150) { // Ensure boxes don't spawn right on top of player
            boxes.push(new Box(x, y));
            return;
        }
    }
}

function createExplosion(x, y, color, count=15) {
    for (let i = 0; i < count; i++) {
        particles.push(new Particle(x, y, color, rand(2, 8)));
    }
    AudioSys.explode();
}

function initGame() {
    player = new Player();
    bullets = [];
    particles = [];
    boxes = [];
    enemies = [];
    powerups = [];
    score = 0;
    frame = 0;
    
    // Reset difficulty variables
    enemyBaseSpeed = 1;
    enemySpawnFrequency = 240;
    maxActiveBoxes = 5;

    // Initial Boxes (fewer at start)
    for (let i = 0; i < maxActiveBoxes; i++) spawnBox();
}

function updateDifficulty() {
    // Enemy Speed: Slowly increase enemy base speed
    enemyBaseSpeed = 1 + Math.min(2, Math.floor(score / 2000) * 0.1); // Max speed increase of 2 (1 + 2 = 3)

    // Enemy Spawn Rate: Very slowly decrease spawn frequency (more frequent spawns)
    // Starts at 240 frames (4s), slowly drops towards 60 frames (1s)
    enemySpawnFrequency = Math.max(60, 240 - Math.floor(score / 300));

    // Max Active Boxes: Slowly increase the number of boxes
    maxActiveBoxes = Math.min(20, 5 + Math.floor(score / 1500)); // Max 20 boxes
}


function update() {
    frame++;
    updateDifficulty(); // Update difficulty based on score

    // If client mode (non-host), skip authoritative spawning & physics; rely on host state
    if (isClient && !isHost) {
        // Update particles and bullets for visual smoothing
        bullets.forEach(b => b.update());
        particles.forEach(p => p.update());
        // UI only (score comes from host)
        document.getElementById('score').innerText = `SCORE: ${score}`;
        // update hp bar if we have player object
        if (player) document.getElementById('hpBar').style.width = `${player.hp}%`;
        return;
    }

    // Spawning Boxes
    if (frame % 120 === 0 && boxes.length < maxActiveBoxes) spawnBox();
    
    // Enemy Spawn Logic
    if (frame % enemySpawnFrequency === 0) enemies.push(new Enemy(player, enemyBaseSpeed));

    // Player Logic
    player.updateFromInput({ keys: input.keys, moveX: 0, moveY: 0 });
    if (player.cooldown > 0) player.cooldown--;
    
    // Host: process remote inputs and potentially spawn bullets for remote players
    if (isHost) processRemoteInputs();

    // Shooting - local player
    if (input.mouse.down && player.cooldown <= 0 && !isClient) {
        const angle = Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x);
        
        bullets.push(new Bullet(player.x, player.y, angle));
        if (player.weapon === 3) {
            bullets.push(new Bullet(player.x, player.y, angle - 0.2));
            bullets.push(new Bullet(player.x, player.y, angle + 0.2));
        }
        player.cooldown = player.fireRate; // Use player's fire rate
        AudioSys.shoot();

        // If host, optionally notify clients? host will broadcast full state so no extra messaging required
    }

    // Entities Update & Clean
    bullets.forEach(b => b.update());
    particles.forEach(p => p.update());
    enemies.forEach(e => e.update());

    // Collisions
    
    // Bullets vs Boxes/Enemies
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        
        // Vs Boxes
        for (let j = boxes.length - 1; j >= 0; j--) {
            const box = boxes[j];
            if (checkCircleRect({x: b.x, y: b.y, r: b.r}, box)) {
                b.dead = true;
                box.hp--;
                createExplosion(b.x, b.y, box.color, 3);
                AudioSys.hit();
                
                if (box.hp <= 0) {
                    box.dead = true;
                    score += (box.type === 1 ? 50 : 10);
                    createExplosion(box.x + box.w/2, box.y + box.h/2, box.color, 20);
                    vibrate(30);
                    
                    // Puzzle Chain Reaction
                    if (box.type === 2) {
                        // Explode nearby boxes
                        boxes.forEach(other => {
                            const d = Math.sqrt((other.x - (box.x + box.w/2))**2 + (other.y - (box.y + box.h/2))**2);
                            if (d < 200 && other !== box && !other.dead) { // Ensure not already dead
                                other.hp = 0; // Destroy immediately
                                other.dead = true;
                                score += 20;
                                createExplosion(other.x + other.w/2, other.y + other.h/2, '#f0f', 10);
                            }
                        });
                        // Clear nearby enemies
                        enemies.forEach(en => {
                             const d = Math.sqrt((en.x - (box.x + box.w/2))**2 + (en.y - (box.y + box.h/2))**2);
                             if (d < 250 && !en.dead) {
                                 en.dead = true;
                                 createExplosion(en.x, en.y, '#f00', 15);
                                 score += 100;
                             }
                        });
                        vibrate(100); // Stronger vibration for puzzle explosion
                    }

                    // Drop Powerup Chance
                    if (Math.random() < 0.2) {
                        powerups.push(new Powerup(box.x + box.w/2, box.y + box.h/2));
                    }
                }
            }
        }

        // Vs Enemies
        for (let k = enemies.length - 1; k >= 0; k--) {
            const e = enemies[k];
            const dx = b.x - e.x;
            const dy = b.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < e.r + b.r) {
                b.dead = true;
                e.hp--;
                AudioSys.hit();
                if (e.hp <= 0) {
                    e.dead = true;
                    score += 100;
                    createExplosion(e.x, e.y, '#f00', 20);
                }
            }
        }
    }

    // Player vs Powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        const dist = Math.sqrt((p.x - player.x)**2 + (p.y - player.y)**2);
        if (dist < p.r + player.r) {
            p.dead = true;
            AudioSys.powerup();
            if (p.type === 'hp') player.hp = Math.min(player.maxHp, player.hp + 20);
            if (p.type === 'tri') { player.weapon = 3; player.weaponTimer = 300; } // 5 seconds
        }
    }

    // Enemy vs Player
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dist = Math.sqrt((e.x - player.x)**2 + (e.y - player.y)**2);
        if (dist < e.r + player.r) {
            e.dead = true;
            player.hp -= 15;
            vibrate(200);
            createExplosion(player.x, player.y, '#f00', 10);
            AudioSys.explode(); // heavy sound
        }
    }

    // Update remote player collisions vs environment (optional)
    // Could also apply enemy collisions with remote players: for brevity this demo doesn't handle remote player collisions with enemies/boxes extensively.

    // Cleanup arrays
    bullets = bullets.filter(b => !b.dead);
    particles = particles.filter(p => p.alpha > 0);
    boxes = boxes.filter(b => !b.dead);
    enemies = enemies.filter(e => !e.dead);
    powerups = powerups.filter(p => !p.dead);

    // Update UI
    document.getElementById('score').innerText = `SCORE: ${score}`;
    document.getElementById('hpBar').style.width = `${player.hp}%`;

    // Game Over Check
    if (player.hp <= 0) {
        gameOver();
        return;
    }
}

function draw() {
    // Clear & Trail Effect
    ctx.fillStyle = 'rgba(5, 5, 16, 0.4)'; // Leaves a trail
    ctx.fillRect(0, 0, width, height);

    ctx.globalCompositeOperation = 'lighter'; // Additive blending for neon look

    // Draw Grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    const gridSize = 50;
    const offset = (frame * 0.5) % gridSize; // Slower grid movement
    for (let x = 0; x < width; x+=gridSize) {
        ctx.beginPath(); ctx.moveTo(x + offset, 0); ctx.lineTo(x + offset, height); ctx.stroke();
    }
    for (let y = 0; y < height; y+=gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y + offset); ctx.lineTo(width, y + offset); ctx.stroke();
    }
    
    boxes.forEach(b => b.draw(ctx));
    powerups.forEach(p => p.draw(ctx));
    // draw host player and remote players
    if (player) player.draw(ctx);
    // remotePlayers map
    for (const id of Object.keys(remotePlayers)) {
        const rp = remotePlayers[id];
        if (rp) rp.draw(ctx);
    }
    bullets.forEach(b => b.draw(ctx));
    enemies.forEach(e => e.draw(ctx));
    particles.forEach(p => p.draw(ctx));

    ctx.globalCompositeOperation = 'source-over'; // Reset blending
}

function loop() {
    update();
    draw();
    if (!isClient || isHost) {
        // host or singleplayer runs authoritative loop
        gameLoopId = requestAnimationFrame(loop);
    } else {
        // client uses loop but we still want animation
        gameLoopId = requestAnimationFrame(loop);
    }
}

/**
 * GAME STATE MANAGEMENT
 */
function showSingle() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('screens').classList.add('hidden');
    AudioSys.init();
    initGame();
    loop();
}

function showMultiplayer() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('mpScreen').classList.remove('hidden');
    document.getElementById('hostArea').style.display = 'none';
    document.getElementById('joinArea').style.display = 'none';
}

function backToMain() {
    document.getElementById('mpScreen').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
}

function startGame() {
    // default singleplayer start (keeps same behavior)
    document.getElementById('screens').classList.add('hidden');
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    
    AudioSys.init(); // Initialize audio context on user interaction
    initGame();
    loop();
}

function gameOver() {
    cancelAnimationFrame(gameLoopId);
    document.getElementById('screens').classList.remove('hidden');
    document.getElementById('gameOverScreen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = `Final Score: ${score}`;
    
    updateLeaderboard(score);
}

/**
 * Leaderboard
 */
function updateLeaderboard(newScore) {
    let scores = JSON.parse(localStorage.getItem('neon_scores') || '[]');
    if (newScore > 0) { // Only add if it's a real score
        scores.push({date: new Date().toLocaleDateString(), score: newScore});
    }
    scores.sort((a, b) => b.score - a.score);
    scores = scores.slice(0, 5); // Keep top 5
    localStorage.setItem('neon_scores', JSON.stringify(scores));

    const lbDiv = document.getElementById('leaderboardContent');
    lbDiv.innerHTML = '<h3>HIGH SCORES</h3>';
    if (scores.length === 0) {
        lbDiv.innerHTML += '<p>No scores yet.</p>';
    } else {
        scores.forEach((s, i) => {
            lbDiv.innerHTML += `<div class="lb-row"><span>${i+1}. ${s.date}</span><span>${s.score}</span></div>`;
        });
    }
}

// Initial Leaderboard Load
// updateLeaderboard(0); -- this is triggered on load earlier

/**
 * Client: send input state to host regularly
 */
function gatherLocalInputForClient() {
    // compute movement vector
    let moveX = 0, moveY = 0;
    if (input.keys['w'] || input.keys['arrowup']) moveY = -1;
    if (input.keys['s'] || input.keys['arrowdown']) moveY = 1;
    if (input.keys['a'] || input.keys['arrowleft']) moveX = -1;
    if (input.keys['d'] || input.keys['arrowright']) moveX = 1;

    // joystick override
    if (input.touch.joystickActive) {
        const jdx = input.touch.currX - input.touch.startX;
        const jdy = input.touch.currY - input.touch.startY;
        const dist = Math.sqrt(jdx*jdx + jdy*jdy);
        const maxDist = 50;
        const force = Math.min(dist, maxDist) / maxDist;
        const angle = Math.atan2(jdy, jdx);
        moveX = Math.cos(angle) * force;
        moveY = Math.sin(angle) * force;
    }

    // aim vector: direction from (center of screen / estimated player position) to mouse
    let aimX = input.mouse.x - (player ? player.x : width/2);
    let aimY = input.mouse.y - (player ? player.y : height/2);
    const dist = Math.sqrt(aimX*aimX + aimY*aimY);
    if (dist > 0.00001) { aimX /= dist; aimY /= dist; }
    const msg = {
        type:'input',
        id: clientId,
        moveX, moveY,
        aimX, aimY,
        shooting: input.mouse.down,
        keys: input.keys
    };
    if (window._clientDC && window._clientDC.readyState === 'open') {
        try { window._clientDC.send(JSON.stringify(msg)); } catch(e) {}
    }
}

// send inputs at ~30Hz
setInterval(() => {
    if (isClient && window._clientDC && window._clientDC.readyState === 'open') {
        gatherLocalInputForClient();
    }
}, 1000/30);

/**
 * Convenience: when host creates initial invite at UI click
 */
function startHostUI() {
    startHost().catch(console.error);
}

/**
 * Utilities to expose some functions to UI buttons
 */
window.createInvite = createInvite;
window.applyAnswer = applyAnswer;
window.startHost = startHost;
window.prepareJoin = prepareJoin;
window.createAnswerFromPaste = createAnswerFromPaste;
window.showSingle = showSingle;
window.showMultiplayer = showMultiplayer;
window.backToMain = backToMain;

</script>
</body>
</html>

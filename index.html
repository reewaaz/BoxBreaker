<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BOX BREAKER</title>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        /* NEW VISUAL THEME: Midnight Prism - keeps UI layout but updates colors */
        :root {
            --primary: #ff6b6b;   /* warm coral */
            --secondary: #7af27a; /* neon green */
            --accent: #ffd166;    /* soft yellow */
            --bg: linear-gradient(180deg,#041022 0%, #07182b 100%);
            --panel: rgba(255,255,255,0.03);
            --muted: #dfe8f5;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg);
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent mobile scrolling while playing */
            user-select: none;
            color: var(--muted);
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: transparent;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 30;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            color: var(--muted);
            text-shadow: 0 0 8px rgba(0,0,0,0.7);
            font-size: 1.15rem;
            pointer-events: auto;
        }

        .hp-bar-container {
            width: 200px;
            height: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.05);
            background: rgba(255,255,255,0.02);
            overflow: hidden;
            transform: skewX(-10deg);
        }

        .hp-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--accent));
            box-shadow: 0 0 18px rgba(122,242,122,0.08), inset 0 -6px 12px rgba(0,0,0,0.25);
            transition: width 0.2s ease;
        }

        #screens {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(4,8,20,0.88);
            backdrop-filter: blur(4px);
            z-index: 100;
            pointer-events: auto;
            padding: 28px;
            box-sizing: border-box;
            overflow: auto; /* allow scrolling on small screens so QR and controls are reachable */
            -webkit-overflow-scrolling: touch;
        }

        .menu-box {
            text-align: center;
            color: var(--muted);
            max-width: 920px;
            width: 100%;
            padding: 20px;
            border-radius: 12px;
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            box-shadow: 0 18px 40px rgba(0,0,0,0.6);
            pointer-events: auto;
        }

        h1 {
            font-size: 2.8rem;
            margin: 0;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }

        p { margin: 6px 0; color: #bfd6ea; opacity: 0.95; }

        .btn {
            pointer-events: auto;
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 12px 28px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            margin-top: 10px;
            cursor: pointer;
            text-transform: uppercase;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.45);
            transition: transform 0.12s ease, background 0.12s;
        }
        .btn:hover { transform: translateY(-4px); background: rgba(255,255,255,0.02); }

        .hidden { display: none !important; }

        .leaderboard {
            margin-top: 12px;
            text-align: left;
            background: rgba(255,255,255,0.02);
            padding: 14px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.03);
            max-height: 220px;
            overflow-y: auto;
        }

        .lb-row {
            display:flex;
            justify-content:space-between;
            margin-bottom:6px;
            color:#e6eef8;
        }

        .mobile-controls { display:none; position:absolute; bottom:56px; width:100%; justify-content:space-between; padding:0 20px; box-sizing:border-box; opacity:0.4; pointer-events:none; }
        @media (hover:none) and (pointer:coarse) {
            .mobile-controls{ display:flex; }
            h1 { font-size: 1.8rem; }
            .control-circle{ width:78px; height:78px; font-size:12px; }
        }
        .control-circle { width:60px; height:60px; border-radius:50%; border:2px dashed rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:11px; backdrop-filter: blur(3px); }

        /* Multiplayer UI */
        #multiplayerPanel { margin-top:16px; width:100%; display:flex; gap:12px; align-items:center; justify-content:center; flex-direction:column; pointer-events:auto; }
        #qrCode { width:160px; height:160px; padding:6px; border-radius:8px; background: transparent; box-shadow: 0 10px 30px rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; }
        #qrCode canvas, #qrCode img { max-width:100%; height:auto; display:block; }
        #playersList { max-height:140px; overflow-y:auto; width:100%; text-align:left; color:#cfe9d9; }

        .small { font-size:0.86rem; color:#c0c8d6; }

        input[type="text"] { padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background: rgba(255,255,255,0.02); color:var(--muted); }

        /* Make sure menu content doesn't get obscured on very small screens */
        @media (max-height:560px) {
            .menu-box { padding: 12px; }
            #screens { padding: 12px; }
        }
    </style>

    <!-- PeerJS and QR lib -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score">SCORE: 0</div>
            <div class="hp-bar-container"><div class="hp-bar-fill" id="hpBar"></div></div>
        </div>

        <div class="mobile-controls">
            <div class="control-circle">DRAG MOVE</div>
            <div class="control-circle">TAP SHOOT</div>
        </div>
    </div>

    <div id="screens">
        <div class="menu-box" id="startScreen">
            <h1>NEON FRAGMENT</h1>
            <p>Destroy Purple Boxes for Chain Reactions</p>
            <p>WASD/Touch to Move | Click/Tap to Shoot</p>

            <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:8px;">
                <button class="btn" onclick="startGame()">INITIATE</button>
                <button class="btn" onclick="openHostPanel()">HOST MULTIPLAYER</button>
                <button class="btn" onclick="openJoinPanel()">JOIN MULTIPLAYER</button>
            </div>

            <div id="multiplayerPanel">
                <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                    <div class="small">Multiplayer</div>
                </div>

                <div id="hostControls" class="hidden" style="width:100%; align-items:center;">
                    <div class="small">Host Code: <strong id="multiplayerHostId">-</strong></div>
                    <div id="qrCode" aria-hidden="false"></div>

                    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:8px;">
                        <button class="btn" onclick="startGame('host')">START GAME (HOST)</button>
                        <button class="btn" onclick="stopHosting()">STOP HOST</button>
                    </div>

                    <div id="playersList"><strong>Connected Players:</strong><div id="playersConnected"></div></div>
                </div>

                <div id="joinControls" class="hidden" style="width:100%; align-items:center;">
                    <div class="small">Enter Host Code</div>
                    <div style="display:flex; gap:8px; width:100%; justify-content:center;">
                        <input id="hostIdToJoin" type="text" placeholder="Host Code" />
                        <button class="btn" onclick="joinById()">JOIN</button>
                    </div>
                    <div id="joinStatus" class="small">Or scan the host's QR code to join automatically.</div>
                </div>
            </div>
        </div>

        <div class="menu-box hidden" id="gameOverScreen">
            <h1>SYSTEM FAILURE</h1>
            <h2 id="finalScore">Score: 0</h2>
            <div class="leaderboard" id="leaderboardContent"></div>
            <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
                <button class="btn" onclick="startGame()">REBOOT</button>
                <button class="btn" onclick="openJoinPanel()">JOIN MULTIPLAYER</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * This file preserves the original gameplay mechanics and design:
 * - Host runs authoritative simulation (boxes, enemies, bullets).
 * - Clients send input to host and render server snapshots.
 * Changes:
 * - Visual theme updated (CSS above).
 * - Host uses a short alphanumeric Host Code for easier joining (PeerJS created with the code).
 * - QR container and #screens made responsive/scrollable so QR is visible on mobile.
 * - Clients render all connected players from server snapshots so everyone sees each other.
 */

/* ---------------- AUDIO (unchanged) ---------------- */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.1, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot() { this.playTone(600, 'sawtooth', 0.1, 0.05); },
    hit() { this.playTone(200, 'square', 0.1, 0.1); },
    explode() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    powerup() {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(440, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(880, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
    }
};

/* ---------------- CANVAS & INPUT ---------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width, height;
function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const input = { keys: {}, mouse: { x: 0, y: 0, down: false }, touch: { active:false, startX:0, startY:0, currX:0, currY:0, joystickActive:false, id:null } };

window.addEventListener('keydown', e => input.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => { input.mouse.x = e.clientX; input.mouse.y = e.clientY; });
window.addEventListener('mousedown', () => input.mouse.down = true);
window.addEventListener('mouseup', () => input.mouse.down = false);

/* Touch twin-stick */
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for (let i = 0; i < e.touches.length; i++){
        const t = e.touches[i];
        if (t.clientX < width/2 && !input.touch.joystickActive){
            input.touch.joystickActive = true;
            input.touch.startX = t.clientX; input.touch.startY = t.clientY;
            input.touch.currX = t.clientX; input.touch.currY = t.clientY; input.touch.id = t.identifier;
        } else if (t.clientX >= width/2){
            input.mouse.down = true; input.mouse.x = t.clientX; input.mouse.y = t.clientY;
        }
    }
}, {passive:false});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for (let i = 0; i < e.touches.length; i++){
        const t = e.touches[i];
        if (input.touch.joystickActive && t.identifier === input.touch.id){
            input.touch.currX = t.clientX; input.touch.currY = t.clientY;
        } else if (t.clientX >= width/2){
            input.mouse.x = t.clientX; input.mouse.y = t.clientY;
        }
    }
}, {passive:false});
canvas.addEventListener('touchend', e => {
    e.preventDefault();
    let joystickStillActive = false; let shootingStillActive = false;
    for (let i = 0; i < e.touches.length; i++){
        if (e.touches[i].identifier === input.touch.id) joystickStillActive = true;
        if (e.touches[i].clientX >= width/2) shootingStillActive = true;
    }
    if (!joystickStillActive){ input.touch.joystickActive = false; input.touch.id = null; }
    input.mouse.down = shootingStillActive;
}, {passive:false});

/* ---------------- UTILS ---------------- */
const rand = (min, max) => Math.random() * (max - min) + min;
const checkCircleRect = (circle, rect) => {
    let distX = Math.abs(circle.x - rect.x - rect.w / 2);
    let distY = Math.abs(circle.y - rect.y - rect.h / 2);
    if (distX > (rect.w / 2 + circle.r)) return false;
    if (distY > (rect.h / 2 + circle.r)) return false;
    if (distX <= (rect.w / 2)) return true;
    if (distY <= (rect.h / 2)) return true;
    let dx = distX - rect.w / 2; let dy = distY - rect.h / 2;
    return (dx * dx + dy * dy <= (circle.r * circle.r));
};
const vibrate = ms => { if (navigator.vibrate) navigator.vibrate(ms); };

function getJoinUrl(hostCode) {
    const base = window.location.href.split('?')[0];
    return `${base}?join=${encodeURIComponent(hostCode)}`;
}

/* ---------------- ENTITIES ---------------- */
class Particle { constructor(x,y,color,speed){ this.x=x; this.y=y; this.color=color; const a=Math.random()*Math.PI*2; this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed; this.alpha=1; this.decay=rand(0.01,0.03); this.size=rand(1,4);} update(){ this.x+=this.vx; this.y+=this.vy; this.alpha-=this.decay; this.size*=0.95; } draw(ctx){ ctx.save(); ctx.globalAlpha=this.alpha; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.restore(); } }
class Bullet { constructor(x,y,angle,type='normal'){ this.x=x; this.y=y; this.vx=Math.cos(angle)*15; this.vy=Math.sin(angle)*15; this.r=4; this.dead=false; this.type=type; this.color='#fff'; } update(){ this.x+=this.vx; this.y+=this.vy; if (this.x < -50 || this.x > width+50 || this.y < -50 || this.y > height+50) this.dead=true; } draw(ctx){ ctx.save(); ctx.shadowBlur=10; ctx.shadowColor=this.color; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.restore(); } }
class Box { constructor(x,y){ this.w=40; this.h=40; this.x=x; this.y=y; this.type = Math.random() > 0.9 ? 2 : (Math.random() > 0.7 ? 1 : 0); this.hp = this.type === 1 ? 5 : (this.type === 2 ? 1 : 2); this.dead=false; this.color = this.type===2?'#cc77ff':(this.type===1? '#ff9f40':'#5af2ff'); this.pulse = Math.random()*10; } draw(ctx){ this.pulse += 0.09; const glow = Math.sin(this.pulse)*8 + 12; ctx.save(); ctx.shadowBlur = glow; ctx.shadowColor = this.color; ctx.strokeStyle = this.color; ctx.lineWidth=2; ctx.strokeRect(this.x,this.y,this.w,this.h); ctx.globalAlpha=0.28; ctx.fillStyle=this.color; const initialMaxHp = this.type===1?5:(this.type===2?1:2); const fillH=(this.hp/initialMaxHp)*this.h; ctx.fillRect(this.x, this.y + (this.h - fillH), this.w, fillH); ctx.globalAlpha=1; ctx.shadowBlur=0; if(this.type===2){ ctx.fillStyle='#fff'; ctx.font='18px Orbitron'; ctx.fillText('!', this.x+14, this.y+28);} ctx.restore(); } }
class Enemy { constructor(player, baseSpeed){ const side = Math.floor(Math.random()*4); if(side===0){ this.x = rand(0,width); this.y = -60;} else if(side===1){ this.x = width+60; this.y = rand(0,height);} else if(side===2){ this.x = rand(0,width); this.y = height+60;} else { this.x = -60; this.y = rand(0,height);} this.player = player; this.r = 15; this.speed = baseSpeed * rand(0.8,1.2); this.hp=3; this.dead=false; this.color='#ff5577'; } update(){ const angle = Math.atan2(this.player.y - this.y, this.player.x - this.x); this.x += Math.cos(angle)*this.speed; this.y += Math.sin(angle)*this.speed; this.x += Math.sin(Date.now()/120)*0.4; } draw(ctx){ ctx.save(); ctx.shadowBlur=14; ctx.shadowColor=this.color; ctx.strokeStyle=this.color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(this.x + Math.cos(0)*this.r, this.y + Math.sin(0)*this.r); ctx.lineTo(this.x + Math.cos(2.09)*this.r, this.y + Math.sin(2.09)*this.r); ctx.lineTo(this.x + Math.cos(4.18)*this.r, this.y + Math.sin(4.18)*this.r); ctx.closePath(); ctx.stroke(); ctx.restore(); } }
class Powerup { constructor(x,y){ this.x=x; this.y=y; this.r=10; this.type = Math.random()>0.5 ? 'hp' : 'tri'; this.dead=false; } draw(ctx){ const color = this.type==='hp' ? '#00ff88' : '#ffd166'; ctx.save(); ctx.shadowBlur=12; ctx.shadowColor=color; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.font='12px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.type==='hp'?'+':'W', this.x, this.y); ctx.restore(); } }
class Player { constructor(){ this.x = width/2; this.y = height/2; this.r=15; this.color='#5af2ff'; this.speed=6; this.maxHp=100; this.hp=100; this.vx=0; this.vy=0; this.friction=0.9; this.cooldown=0; this.fireRate=8; this.weapon=1; this.weaponTimer=0; this.touchMoveMultiplier=1.5; } updateFromInput(dx,dy) { if (dx!==0 || dy!==0) { this.vx += dx*0.8; this.vy += dy*0.8; } this.vx *= this.friction; this.vy *= this.friction; const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy); if (speed > this.speed) { const ang = Math.atan2(this.vy,this.vx); this.vx = Math.cos(ang)*this.speed; this.vy = Math.sin(ang)*this.speed; } this.x += this.vx; this.y += this.vy; this.x = Math.max(this.r, Math.min(width-this.r, this.x)); this.y = Math.max(this.r, Math.min(height-this.r, this.y)); } draw(ctx){ ctx.save(); ctx.shadowBlur=20; ctx.shadowColor=this.color; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r*0.5,0,Math.PI*2); ctx.fill(); ctx.restore(); } }

/* ---------------- GAME STATE ---------------- */
let player = new Player(); // host local representation
let bullets = [], boxes = [], enemies = [], powerups = [], particles = [];
let score = 0, spawnTimer = 0, enemyBaseSpeed = 1.2;
let gameRunning = false;

/* ---------------- MULTIPLAYER (PeerJS) ---------------- */
/*
 - Host will create a short Host Code (4 chars) and register PeerJS with that id.
 - Clients connect using that Host Code.
 - Host remains authoritative: it runs the simulation, applies client inputs (stored in clientsMap),
   then broadcasts full state to clients. Clients render snapshots.
*/
let peer = null;
let isHost = false;
let isClient = false;
let hostCode = null;
let connections = [];
let clientsMap = {};
let clientConn = null;
let serverState = null;
let qrcodeInstance = null;

const playersListEl = document.getElementById('playersConnected');
const screensEl = document.getElementById('screens');
const startScreenEl = document.getElementById('startScreen');
const gameOverEl = document.getElementById('gameOverScreen');

/* ---------------- HOST CODE UTIL ---------------- */
function makeHostCode(len=4){
    // friendly uppercase alphanumeric (avoid similar chars)
    const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
    let s='';
    for (let i=0;i<len;i++) s += chars.charAt(Math.floor(Math.random()*chars.length));
    return s;
}

function openHostPanel(){
    document.getElementById('hostControls').classList.remove('hidden');
    document.getElementById('joinControls').classList.add('hidden');
    if (!peer) startHosting();
}

function openJoinPanel(){
    document.getElementById('joinControls').classList.remove('hidden');
    document.getElementById('hostControls').classList.add('hidden');
    const urlParams = new URLSearchParams(window.location.search);
    const join = urlParams.get('join');
    if (join) document.getElementById('hostIdToJoin').value = join;
}

/* ---------------- START HOSTING ---------------- */
function startHosting(){
    if (peer) return;
    // generate short host code
    hostCode = makeHostCode();
    // create Peer with explicit id (the short hostCode)
    peer = new Peer(hostCode);
    peer.on('open', id => {
        // id should equal hostCode
        document.getElementById('multiplayerHostId').innerText = id;
        // create QR with join URL
        const joinUrl = getJoinUrl(id);
        const qrEl = document.getElementById('qrCode');
        qrEl.innerHTML = '';
        try {
            qrcodeInstance = new QRCode(qrEl, {
                text: joinUrl,
                width: 160,
                height: 160,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.M
            });
        } catch(e) {
            // fallback: show url text
            qrEl.textContent = joinUrl;
        }
        // ensure QR visible on mobile
        setTimeout(()=>{ try { qrEl.scrollIntoView({behavior:'smooth', block:'center'}); } catch(e){} }, 200);
    });

    peer.on('connection', conn => {
        conn.on('open', () => {
            connections.push(conn);
            // initialize client player entry in host map
            clientsMap[conn.peer] = {
                x: width/2 + rand(-100,100),
                y: height/2 + rand(-100,100),
                vx: 0, vy: 0, r: 14,
                color: '#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0'),
                cooldown: 0,
                fireRate: 8,
                weapon: 1,
                lastInput: { dx:0, dy:0, shoot:false, angle:0 },
                hp: 100
            };
            updateHostPlayersUI();
            try { conn.send({ type:'init', payload:{ hostId: hostCode } }); } catch(e){}
        });

        conn.on('data', data => {
            if (!data || !data.type) return;
            if (data.type === 'join') {
                // already tracked in open
            } else if (data.type === 'input') {
                const p = clientsMap[conn.peer];
                if (p) p.lastInput = data.payload;
            }
        });

        conn.on('close', () => {
            delete clientsMap[conn.peer];
            connections = connections.filter(c => c !== conn);
            updateHostPlayersUI();
        });

        conn.on('error', (err) => { console.warn('conn err', err); });
    });

    peer.on('error', err => console.error('Peer error', err));
}

/* ---------------- STOP HOST ---------------- */
function stopHosting(){
    if (!peer) return;
    connections.forEach(c => { try { c.close(); } catch(e){} });
    connections = [];
    clientsMap = {};
    try { if (peer && peer.destroy) peer.destroy(); } catch(e){}
    peer = null; hostCode = null;
    document.getElementById('multiplayerHostId').innerText = '-';
    const qrEl = document.getElementById('qrCode'); qrEl.innerHTML = '';
    if (qrcodeInstance && qrcodeInstance.clear) try { qrcodeInstance.clear(); } catch(e){}
    updateHostPlayersUI();
}

/* ---------------- BROADCAST ---------------- */
function broadcastStateToClients(){
    if (!isHost) return;
    const state = {
        players: [],
        bullets: bullets.map(b => ({ x:b.x, y:b.y, vx:b.vx, vy:b.vy, r:b.r, color:b.color })),
        boxes: boxes.map(b => ({ x:b.x, y:b.y, w:b.w, h:b.h, hp:b.hp, type:b.type, dead:b.dead, color:b.color })),
        enemies: enemies.map(e => ({ x:e.x, y:e.y, r:e.r, hp:e.hp, color:e.color })),
        powerups: powerups.map(p => ({ x:p.x, y:p.y, r:p.r, type:p.type })),
        score: score,
        hostId: hostCode
    };

    // include host player
    state.players.push({ id: 'host', x: player.x, y: player.y, hp: player.hp, r: player.r, color: player.color });

    for (const pid in clientsMap) {
        const p = clientsMap[pid];
        state.players.push({ id: pid, x: p.x, y: p.y, hp: p.hp || 100, r: p.r, color: p.color });
    }

    connections.forEach(conn => {
        try { conn.send({ type:'state', payload: state }); } catch(e){}
    });
}

/* ---------------- CLIENT: JOIN ---------------- */
function joinById(){
    const hostToJoin = document.getElementById('hostIdToJoin').value.trim().toUpperCase();
    if (!hostToJoin) return alert('Enter host code to join');
    if (clientConn) { try { clientConn.close(); } catch(e){} clientConn = null; }
    if (!peer){
        peer = new Peer(); // client peer can be auto-generated id
        peer.on('open', () => connectToHost(peer, hostToJoin));
        peer.on('error', e => console.error(e));
    } else {
        connectToHost(peer, hostToJoin);
    }
}

function connectToHost(peerInstance, hostToJoin){
    clientConn = peerInstance.connect(hostToJoin);
    clientConn.on('open', () => {
        isClient = true; isHost = false;
        // hide menus
        screensEl.classList.add('hidden');
        startScreenEl.classList.add('hidden');
        gameOverEl.classList.add('hidden');
        // send join
        try { clientConn.send({ type:'join', payload:{} }); } catch(e){}
        // start render and input loop
        clientRenderLoop();
        startSendingInputsToHost();
    });

    clientConn.on('data', msg => {
        if (!msg || !msg.type) return;
        if (msg.type === 'init') {
            hostCode = msg.payload.hostId;
        } else if (msg.type === 'state') {
            serverState = msg.payload;
            if (serverState && serverState.score !== undefined) {
                document.getElementById('score').innerText = `SCORE: ${serverState.score}`;
            }
            const hostPlayer = serverState.players.find(p => p.id === 'host');
            if (hostPlayer) document.getElementById('hpBar').style.width = `${Math.max(0, Math.min(100, hostPlayer.hp || 100))}%`;
        }
    });

    clientConn.on('close', () => {
        isClient = false; clientConn = null; serverState = null;
        stopSendingInputsToHost();
        screensEl.classList.remove('hidden');
        document.getElementById('joinControls').classList.remove('hidden');
    });

    clientConn.on('error', e => console.error('clientConn error', e));
}

/* ---------------- CLIENT INPUT SENDER ---------------- */
let clientInputInterval = null;
function startSendingInputsToHost(){
    if (!clientConn) return;
    if (clientInputInterval) clearInterval(clientInputInterval);
    clientInputInterval = setInterval(() => {
        const mv = getLocalMovementInput();
        const shoot = input.mouse.down;
        const angle = Math.atan2(input.mouse.y - (height/2), input.mouse.x - (width/2));
        try { clientConn.send({ type:'input', payload:{ dx: mv.dx, dy: mv.dy, shoot: shoot, angle: angle } }); } catch(e){}
    }, 60);
}
function stopSendingInputsToHost(){ if (clientInputInterval) { clearInterval(clientInputInterval); clientInputInterval = null; } }

/* ---------------- INPUT HELPER ---------------- */
function getLocalMovementInput(){
    let dx = 0, dy = 0;
    if (input.keys['w'] || input.keys['arrowup']) dy = -1;
    if (input.keys['s'] || input.keys['arrowdown']) dy = 1;
    if (input.keys['a'] || input.keys['arrowleft']) dx = -1;
    if (input.keys['d'] || input.keys['arrowright']) dx = 1;
    if (input.touch.joystickActive){
        const jdx = input.touch.currX - input.touch.startX;
        const jdy = input.touch.currY - input.touch.startY;
        const dist = Math.sqrt(jdx*jdx + jdy*jdy);
        const maxDist = 50;
        const force = Math.min(dist, maxDist) / maxDist;
        const angle = Math.atan2(jdy, jdx);
        dx = Math.cos(angle) * force; dy = Math.sin(angle) * force;
    }
    return { dx, dy };
}

/* ---------------- HOST UI: list connected players ---------------- */
function updateHostPlayersUI(){
    if (!playersListEl) return;
    const ids = Object.keys(clientsMap);
    if (ids.length === 0) {
        playersListEl.innerHTML = '<div class="small" style="padding:6px 0;">No players connected</div>';
        return;
    }
    let html = '';
    ids.forEach(id => {
        const p = clientsMap[id];
        html += `<div class="lb-row"><div style="display:flex;gap:8px;align-items:center;"><div style="width:12px;height:12px;border-radius:50%;background:${p.color};"></div><div style="font-size:0.9rem;color:#e6eef8;">${id}</div></div><div style="color:#cfe9d9">${Math.round(p.hp||100)}%</div></div>`;
    });
    playersListEl.innerHTML = html;
}

/* ---------------- HOST SIMULATION (original gameplay) ---------------- */
let hostLoopId = null;
let broadcastIntervalId = null;

function hostStartGameLoop(){
    if (hostLoopId) return;
    gameRunning = true;
    bullets = []; boxes = []; enemies = []; powerups = []; particles = []; score = 0; spawnTimer = 0;

    // populate boxes (same as original design)
    for (let i=0;i<6;i++){
        for (let j=0;j<4;j++){
            boxes.push(new Box(100 + i*80 + rand(-8,8), 60 + j*72 + rand(-6,6)));
        }
    }

    function hostStep(){
        // host player's input (local)
        const mv = getLocalMovementInput();
        player.updateFromInput(mv.dx, mv.dy);
        if (input.mouse.down && player.cooldown <= 0){
            shootBulletFrom(player.x, player.y, Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x), 'host');
            player.cooldown = player.fireRate;
            AudioSys.shoot();
        }
        if (player.cooldown > 0) player.cooldown--;

        // apply client inputs to their simulated players
        for (const pid in clientsMap){
            const c = clientsMap[pid];
            const inp = c.lastInput || { dx:0, dy:0, shoot:false, angle:0 };
            // movement
            c.vx = (c.vx || 0) * 0.9 + (inp.dx || 0) * 0.8;
            c.vy = (c.vy || 0) * 0.9 + (inp.dy || 0) * 0.8;
            c.x += c.vx; c.y += c.vy;
            c.x = Math.max(c.r, Math.min(width - c.r, c.x)); c.y = Math.max(c.r, Math.min(height - c.r, c.y));
            // shooting
            c.cooldown = c.cooldown || 0;
            if (inp.shoot && c.cooldown <= 0){
                shootBulletFrom(c.x, c.y, inp.angle, pid);
                c.cooldown = c.fireRate;
            }
            if (c.cooldown > 0) c.cooldown--;
        }

        // bullets
        bullets.forEach(b => b.update());
        bullets = bullets.filter(b => !b.dead);

        // bullets vs boxes
        bullets.forEach(b => {
            boxes.forEach(box => {
                if (!box.dead && checkCircleRect(b, { x: box.x, y: box.y, w: box.w, h: box.h })){
                    box.hp -= 1;
                    b.dead = true;
                    AudioSys.hit();
                    for (let i=0;i<8;i++) particles.push(new Particle(b.x, b.y, box.color, rand(1,5)));
                    if (box.hp <= 0) {
                        box.dead = true;
                        score += 10;
                        AudioSys.explode();
                        if (box.type === 2){
                            // explosive chain reaction
                            boxes.forEach(other => {
                                const dx = other.x - box.x, dy = other.y - box.y;
                                if (Math.abs(dx) < 120 && Math.abs(dy) < 120 && !other.dead){
                                    other.hp -= 1;
                                    if (other.hp <= 0){ other.dead = true; score += 7; }
                                }
                            });
                        }
                        for (let p=0;p<18;p++) particles.push(new Particle(box.x + box.w/2, box.y + box.h/2, box.color, rand(1,6)));
                        if (Math.random() < 0.12) powerups.push(new Powerup(box.x + box.w/2, box.y + box.h/2));
                    }
                }
            });
        });

        // spawn enemies
        spawnTimer--;
        if (spawnTimer <= 0){
            enemies.push(new Enemy(player, enemyBaseSpeed + score * 0.002));
            spawnTimer = Math.floor(rand(80, 140));
        }
        enemies.forEach(e => e.update());

        // bullets vs enemies
        bullets.forEach(b => {
            enemies.forEach(en => {
                const dx = b.x - en.x, dy = b.y - en.y, d2 = dx*dx + dy*dy;
                if (d2 < (b.r + en.r)*(b.r + en.r)){
                    en.hp -= 1; b.dead = true; AudioSys.hit();
                }
            });
        });

        enemies = enemies.filter(e => {
            if (e.hp <= 0) { score += 5; for (let i=0;i<12;i++) particles.push(new Particle(e.x, e.y, e.color, rand(1.5,5))); return false; }
            // enemy hits host player
            const dx = e.x - player.x, dy = e.y - player.y, dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < e.r + player.r){
                player.hp -= 10;
                e.x -= (dx/dist)*8; e.y -= (dy/dist)*8;
                AudioSys.hit(); vibrate(40);
                if (player.hp <= 0) { gameOver('host'); }
            }
            return true;
        });

        // powerup pickups (host and clients)
        powerups.forEach(pu => {
            const dx = pu.x - player.x, dy = pu.y - player.y;
            if (dx*dx + dy*dy < (pu.r + player.r)*(pu.r + player.r)){
                if (pu.type === 'hp'){ player.hp = Math.min(player.maxHp, player.hp + 30); }
                else if (pu.type === 'tri'){ player.weapon = 3; player.weaponTimer = 300; }
                pu.dead = true; AudioSys.powerup();
            }
            for (const pid in clientsMap){
                const c = clientsMap[pid];
                const dx2 = pu.x - c.x, dy2 = pu.y - c.y;
                if (dx2*dx2 + dy2*dy2 < (pu.r + c.r)*(pu.r + c.r)){
                    c.hp = Math.min(100, (c.hp || 100) + 25);
                    pu.dead = true;
                }
            }
        });
        powerups = powerups.filter(p => !p.dead);

        boxes = boxes.filter(b => !b.dead);

        particles.forEach(p => p.update());
        particles = particles.filter(p => p.alpha > 0.03);

        // update HUD
        document.getElementById('score').innerText = `SCORE: ${score}`;
        document.getElementById('hpBar').style.width = `${Math.max(0, Math.min(100, player.hp))}%`;

        hostLoopId = requestAnimationFrame(hostStep);
    }

    hostStep();
    // broadcast roughly 12 times/sec
    if (broadcastIntervalId) clearInterval(broadcastIntervalId);
    broadcastIntervalId = setInterval(broadcastStateToClients, 85);
}

/* ---------------- HOST STOP SIM ---------------- */
function hostStopGameLoop(){
    if (hostLoopId) cancelAnimationFrame(hostLoopId);
    hostLoopId = null;
    if (broadcastIntervalId) clearInterval(broadcastIntervalId);
    broadcastIntervalId = null;
    gameRunning = false;
}

/* ---------------- CLIENT RENDER LOOP - renders serverState (shows all players) ---------------- */
let clientRenderFrame = null;
function clientRenderLoop(){
    function render(){
        ctx.clearRect(0,0,width,height);

        // subtle background grid
        ctx.save();
        ctx.globalAlpha = 0.03;
        ctx.fillStyle = '#ffffff';
        for (let gx = 0; gx < width; gx += 40) ctx.fillRect(gx, 0, 1, height);
        for (let gy = 0; gy < height; gy += 40) ctx.fillRect(0, gy, width, 1);
        ctx.restore();

        if (serverState){
            // boxes
            serverState.boxes.forEach(b => {
                ctx.save();
                ctx.strokeStyle = b.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
                ctx.restore();
            });

            // bullets
            serverState.bullets.forEach(bb => {
                ctx.save();
                ctx.fillStyle = bb.color || '#fff';
                ctx.beginPath();
                ctx.arc(bb.x, bb.y, bb.r, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            });

            // enemies
            serverState.enemies.forEach(e => {
                ctx.save();
                ctx.strokeStyle = e.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(e.x + Math.cos(0)*e.r, e.y + Math.sin(0)*e.r);
                ctx.lineTo(e.x + Math.cos(2.09)*e.r, e.y + Math.sin(2.09)*e.r);
                ctx.lineTo(e.x + Math.cos(4.18)*e.r, e.y + Math.sin(4.18)*e.r);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            });

            // players (host + clients)
            serverState.players.forEach(p => {
                ctx.save();
                ctx.fillStyle = p.color || '#5af2ff';
                ctx.shadowBlur = 18; ctx.shadowColor = p.color || '#5af2ff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();

                // name/label
                ctx.save();
                ctx.fillStyle = '#e6eef8';
                ctx.font = '10px Orbitron';
                const label = p.id === 'host' ? 'HOST' : p.id;
                ctx.fillText(label, p.x - 16, p.y - p.r - 6);
                ctx.restore();
            });

            // powerups
            serverState.powerups.forEach(pu => {
                ctx.save();
                ctx.fillStyle = pu.type === 'hp' ? '#00ff88' : '#ffd166';
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, pu.r, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            });
        } else {
            // fallback: draw the local world (singleplayer/host)
            boxes.forEach(b => b.draw(ctx));
            bullets.forEach(b => b.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            powerups.forEach(p => p.draw(ctx));
            player.draw(ctx);
            particles.forEach(p => p.draw(ctx));
        }

        clientRenderFrame = requestAnimationFrame(render);
    }
    render();
}

/* ---------------- shoot helper ---------------- */
function shootBulletFrom(x,y,angle,owner){
    const b = new Bullet(x,y,angle);
    b.color = '#fff';
    b.owner = owner || 'host';
    bullets.push(b);
}

/* ---------------- START GAME (solo or host) ---------------- */
function startGame(mode){
    AudioSys.init();
    screensEl.classList.add('hidden');
    startScreenEl.classList.add('hidden');
    gameOverEl.classList.add('hidden');

    // reset local player & state
    player = new Player();
    player.x = width/2; player.y = height/2;
    score = 0;

    if (mode === 'host'){
        if (!peer) startHosting();
        isHost = true; isClient = false;
        hostStartGameLoop();
    } else {
        // solo play (no host)
        isHost = false; isClient = false; gameRunning = true;
        bullets = []; boxes = []; enemies = []; powerups = []; particles = []; score = 0;
        for (let i=0;i<6;i++) for (let j=0;j<4;j++) boxes.push(new Box(100 + i*80, 60 + j*72));
        // reuse clientRenderLoop for drawing local arrays
        clientRenderLoop();

        // simple local loop to move things (keeps original gameplay)
        let loopId = null;
        function step(){
            const mv = getLocalMovementInput();
            player.updateFromInput(mv.dx, mv.dy);
            if (input.mouse.down && player.cooldown <= 0){
                shootBulletFrom(player.x, player.y, Math.atan2(input.mouse.y - player.y, input.mouse.x - player.x), 'host');
                player.cooldown = player.fireRate; AudioSys.shoot();
            }
            if (player.cooldown > 0) player.cooldown--;

            bullets.forEach(b => b.update());
            bullets = bullets.filter(b => !b.dead);

            bullets.forEach(b => {
                boxes.forEach(box => {
                    if (!box.dead && checkCircleRect(b, { x: box.x, y: box.y, w: box.w, h: box.h })){
                        box.hp -= 1; b.dead = true; AudioSys.hit();
                        if (box.hp <= 0){ box.dead = true; score += 10; AudioSys.explode(); }
                    }
                });
            });
            boxes = boxes.filter(b => !b.dead);

            loopId = requestAnimationFrame(step);
        }
        step();
    }
}

/* ---------------- GAME OVER ---------------- */
function gameOver(mode){
    gameRunning = false;
    if (mode === 'host' && isHost) {
        hostStopGameLoop();
    }
    screensEl.classList.remove('hidden');
    gameOverEl.classList.remove('hidden');
    document.getElementById('finalScore').innerText = `Score: ${score}`;
    const lb = document.getElementById('leaderboardContent');
    let html = `<div class="lb-row"><div style="color:${getComputedStyle(document.documentElement).getPropertyValue('--accent')};">YOU</div><div>${score}</div></div>`;
    if (isHost) {
        for (const pid in clientsMap){
            html += `<div class="lb-row"><div>${pid}</div><div>${Math.round(clientsMap[pid].hp||100)}</div></div>`;
        }
    }
    lb.innerHTML = html;
}

/* ---------------- Ensure QR visible on mobile ---------------- */
function ensureQrVisible(){
    const qrEl = document.getElementById('qrCode');
    if (!qrEl) return;
    try{ qrEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch(e){}
}

/* ---------------- Misc ---------------- */
document.addEventListener('click', () => { AudioSys.init(); });

window.addEventListener('beforeunload', () => {
    stopHosting();
    try { if (peer && peer.destroy) peer.destroy(); } catch(e){}
});

/* ---------------- Auto-join URL param (fills input only) ---------------- */
(function autoJoinFromUrl(){
    const urlParams = new URLSearchParams(window.location.search);
    const join = urlParams.get('join');
    if (join){
        document.getElementById('hostIdToJoin').value = join;
        openJoinPanel();
        // do not auto-connect without user interaction (audio/user-gesture policies)
    }
})();

/* ---------------- Expose functions for UI ---------------- */
window.startGame = startGame;
window.openHostPanel = openHostPanel;
window.openJoinPanel = openJoinPanel;
window.startHosting = startHosting;
window.stopHosting = stopHosting;
window.joinById = joinById;

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NEON FRAGMENT: OVERDRIVE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f3ff;
            --secondary: #ff00ff;
            --danger: #ff3333;
            --bg: #050510;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg);
            font-family: 'Orbitron', sans-serif;
            color: white;
        }

        /* Game Layer */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding-top: 10px;
        }

        .score-box {
            font-size: 1.5rem;
            font-weight: 700;
            text-shadow: 0 0 10px var(--primary);
        }

        .hp-container {
            width: 200px;
            max-width: 40%;
            height: 15px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5);
            transform: skewX(-20deg);
            overflow: hidden;
        }

        .hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--secondary), var(--primary));
            box-shadow: 0 0 10px var(--secondary);
            transition: width 0.2s ease-out;
        }

        /* Mobile Hints */
        .controls-hint {
            display: none;
            width: 100%;
            justify-content: space-between;
            padding-bottom: 40px;
            opacity: 0.4;
            font-size: 0.8rem;
            letter-spacing: 2px;
        }

        @media (hover: none) and (pointer: coarse) {
            .controls-hint { display: flex; }
        }

        /* Menus */
        #menu-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 0.3s;
        }

        .modal {
            text-align: center;
            padding: 40px;
            border: 1px solid var(--primary);
            background: rgba(0,0,0,0.8);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            max-width: 90%;
            width: 500px;
            position: relative;
        }

        .modal::before {
            content: '';
            position: absolute;
            top: -2px; left: -2px; right: -2px; bottom: -2px;
            background: linear-gradient(45deg, var(--primary), transparent, var(--secondary));
            z-index: -1;
            filter: blur(5px);
        }

        h1 {
            font-size: 2.5rem;
            margin: 0 0 10px 0;
            background: linear-gradient(to right, var(--primary), white, var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        p { color: #aaa; margin-bottom: 30px; line-height: 1.5; }

        .btn {
            background: transparent;
            color: var(--primary);
            border: 2px solid var(--primary);
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 20px var(--primary);
            transform: scale(1.05);
        }

        .hidden { display: none !important; opacity: 0; pointer-events: none; }

        .leaderboard {
            margin: 20px 0;
            text-align: left;
            font-size: 0.9rem;
            color: #ccc;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
        .lb-row { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px dashed #333; }
        .lb-row span:nth-child(1) { color: var(--primary); }
        .lb-row span:nth-child(2) { color: white; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-box" id="scoreDisplay">000000</div>
            <div class="hp-container"><div class="hp-fill" id="hpBar"></div></div>
        </div>
        <div class="controls-hint">
            <div><span style="color:var(--primary)">LEFT</span> TO MOVE</div>
            <div><span style="color:var(--secondary)">RIGHT</span> TO SHOOT</div>
        </div>
    </div>

    <div id="menu-layer">
        <div id="startMenu" class="modal">
            <h1>Neon Fragment</h1>
            <p>Destabilize the system. Destroy purple nodes for chain reactions.</p>
            <button class="btn" onclick="Game.start()">INITIALIZE</button>
        </div>
        
        <div id="gameOverMenu" class="modal hidden">
            <h1 style="color: var(--danger)">CRITICAL ERROR</h1>
            <p id="finalScoreMsg">Score: 0</p>
            <div class="leaderboard" id="lbContent"></div>
            <button class="btn" onclick="Game.start()">REBOOT SYSTEM</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * AUDIO SYSTEM
 * Procedural audio generation using Web Audio API
 */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone(freq, type, duration, vol = 0.1, slide = false) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slide) osc.frequency.exponentialRampToValueAtTime(freq * 0.1, this.ctx.currentTime + duration);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot() { this.playTone(400, 'triangle', 0.1, 0.05, true); },
    hit() { this.playTone(200, 'square', 0.1, 0.05, true); },
    powerup() { 
        if (!this.ctx) return;
        this.playTone(600, 'sine', 0.1, 0.1);
        setTimeout(() => this.playTone(1200, 'sine', 0.2, 0.1), 100);
    },
    explode() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 sec
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        noise.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    }
};

/**
 * RENDERER & INPUT
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on canvas bg
let width, height;

// High DPI Canvas Setup
function resize() {
    const dpr = window.devicePixelRatio || 1;
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);
}
window.addEventListener('resize', resize);
resize();

const Input = {
    keys: {},
    mouse: { x: width/2, y: height/2, down: false },
    stick: { active: false, startX: 0, startY: 0, currX: 0, currY: 0, id: null },
    fireTouch: { active: false, x: 0, y: 0, id: null },

    init() {
        // Keyboard
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        
        // Mouse
        window.addEventListener('mousemove', e => { this.mouse.x = e.clientX; this.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);

        // Touch
        canvas.addEventListener('touchstart', e => this.handleTouch(e), {passive: false});
        canvas.addEventListener('touchmove', e => this.handleTouch(e), {passive: false});
        canvas.addEventListener('touchend', e => this.handleTouchEnd(e), {passive: false});
    },

    handleTouch(e) {
        e.preventDefault(); // Prevent scrolling
        for (let i = 0; i < e.touches.length; i++) {
            const t = e.touches[i];
            const isLeft = t.clientX < width / 2;
            
            // Joystick Logic (Left Side)
            if (isLeft) {
                if (!this.stick.active) {
                    this.stick.active = true;
                    this.stick.startX = t.clientX;
                    this.stick.startY = t.clientY;
                    this.stick.currX = t.clientX;
                    this.stick.currY = t.clientY;
                    this.stick.id = t.identifier;
                } else if (this.stick.id === t.identifier) {
                    this.stick.currX = t.clientX;
                    this.stick.currY = t.clientY;
                }
            } 
            // Firing Logic (Right Side)
            else {
                this.fireTouch.active = true;
                this.fireTouch.x = t.clientX;
                this.fireTouch.y = t.clientY;
                this.fireTouch.id = t.identifier;
                // Update mouse pos for compatibility
                this.mouse.x = t.clientX;
                this.mouse.y = t.clientY;
            }
        }
    },

    handleTouchEnd(e) {
        e.preventDefault();
        let stickFound = false;
        let fireFound = false;

        for (let i = 0; i < e.touches.length; i++) {
            if (e.touches[i].identifier === this.stick.id) stickFound = true;
            if (e.touches[i].identifier === this.fireTouch.id) fireFound = true;
        }

        if (!stickFound) this.stick.active = false;
        if (!fireFound) this.fireTouch.active = false;
    },

    getMovementVector() {
        // Keyboard
        let dx = 0, dy = 0;
        if (this.keys['w'] || this.keys['arrowup']) dy = -1;
        if (this.keys['s'] || this.keys['arrowdown']) dy = 1;
        if (this.keys['a'] || this.keys['arrowleft']) dx = -1;
        if (this.keys['d'] || this.keys['arrowright']) dx = 1;

        // Joystick Override
        if (this.stick.active) {
            const maxDrag = 60;
            const diffX = this.stick.currX - this.stick.startX;
            const diffY = this.stick.currY - this.stick.startY;
            const dist = Math.sqrt(diffX*diffX + diffY*diffY);
            const force = Math.min(dist, maxDrag) / maxDrag;
            const angle = Math.atan2(diffY, diffX);
            dx = Math.cos(angle) * force;
            dy = Math.sin(angle) * force;
        }
        return { dx, dy };
    },

    isShooting() {
        return this.mouse.down || this.fireTouch.active;
    }
};

/**
 * GAME ENTITIES
 */
class Entity {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.dead = false;
    }
}

class Player extends Entity {
    constructor() {
        super(width/2, height/2, '#00f3ff');
        this.vx = 0; this.vy = 0;
        this.r = 12;
        this.speed = 5;
        this.friction = 0.92;
        this.hp = 100;
        this.cooldown = 0;
        this.weaponLevel = 1; // 1=Single, 2=Dual, 3=Tri
        this.weaponTimer = 0;
    }

    update() {
        const move = Input.getMovementVector();
        
        // Acceleration
        if (move.dx !== 0 || move.dy !== 0) {
            this.vx += move.dx * 0.8;
            this.vy += move.dy * 0.8;
        }

        // Friction & Cap
        this.vx *= this.friction;
        this.vy *= this.friction;
        const vel = Math.sqrt(this.vx**2 + this.vy**2);
        if (vel > this.speed) {
            const angle = Math.atan2(this.vy, this.vx);
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        }

        this.x += this.vx;
        this.y += this.vy;

        // Bounds
        this.x = Math.max(this.r, Math.min(width - this.r, this.x));
        this.y = Math.max(this.r, Math.min(height - this.r, this.y));

        // Weapon Timer
        if (this.weaponTimer > 0) {
            this.weaponTimer--;
            if (this.weaponTimer <= 0) this.weaponLevel = 1;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r*0.6, 0, Math.PI*2); ctx.fill();
    }
}

class Bullet extends Entity {
    constructor(x, y, angle) {
        super(x, y, '#ffffff');
        this.vx = Math.cos(angle) * 12;
        this.vy = Math.sin(angle) * 12;
        this.r = 3;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) this.dead = true;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
    }
}

class Enemy extends Entity {
    constructor(player) {
        super(0, 0, '#ff3333');
        this.player = player;
        // Spawn logic
        const side = Math.floor(Math.random()*4);
        if(side===0) { this.x = Math.random()*width; this.y = -30; }
        else if(side===1) { this.x = width+30; this.y = Math.random()*height; }
        else if(side===2) { this.x = Math.random()*width; this.y = height+30; }
        else { this.x = -30; this.y = Math.random()*height; }
        
        this.speed = Math.random() * 1.5 + 1;
        this.r = 10;
        this.angle = 0;
    }
    update() {
        this.angle = Math.atan2(this.player.y - this.y, this.player.x - this.x);
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        this.x += Math.cos(Date.now()/200) * 0.5; // Jitter
    }
    draw(ctx) {
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        ctx.moveTo(10, 0); ctx.lineTo(-8, 8); ctx.lineTo(-8, -8);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }
}

class Box extends Entity {
    constructor(x, y) {
        super(x, y, '#00f3ff');
        this.w = 30; this.h = 30;
        this.type = Math.random() > 0.85 ? 'puzzle' : (Math.random() > 0.7 ? 'hard' : 'normal');
        this.hp = this.type === 'hard' ? 4 : (this.type === 'puzzle' ? 1 : 2);
        this.maxHp = this.hp;
        this.color = this.type === 'puzzle' ? '#ff00ff' : (this.type === 'hard' ? '#ffa500' : '#00f3ff');
        this.pulse = Math.random() * Math.PI;
    }
    update() { this.pulse += 0.05; }
    draw(ctx) {
        const scale = 1 + Math.sin(this.pulse)*0.05;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        
        // Draw Fill based on HP
        ctx.fillStyle = this.color;
        ctx.globalAlpha = 0.2;
        const fillH = (this.hp / this.maxHp) * this.h;
        ctx.fillRect(this.x, this.y + (this.h - fillH), this.w, fillH);
        ctx.globalAlpha = 1;

        // Stroke
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.scale(scale, scale);
        ctx.strokeRect(-this.w/2, -this.h/2, this.w, this.h);
        if (this.type === 'puzzle') {
            ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; 
            ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText('!', 0, 0);
        }
        ctx.restore();
    }
}

class Particle extends Entity {
    constructor(x, y, color) {
        super(x, y, color);
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * 4;
        this.vx = Math.cos(a) * s;
        this.vy = Math.sin(a) * s;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.01;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= this.decay;
        if(this.life <= 0) this.dead = true;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

/**
 * MAIN GAME MANAGER
 */
const Game = {
    loopId: null,
    player: null,
    bullets: [],
    enemies: [],
    boxes: [],
    particles: [],
    score: 0,
    frame: 0,
    active: false,

    start() {
        AudioSys.init();
        Input.init();
        document.getElementById('menu-layer').classList.add('hidden');
        document.getElementById('gameOverMenu').classList.add('hidden');
        
        this.player = new Player();
        this.bullets = [];
        this.enemies = [];
        this.boxes = [];
        this.particles = [];
        this.score = 0;
        this.frame = 0;
        this.active = true;

        // Init boxes
        for(let i=0; i<6; i++) this.spawnBox();

        if (this.loopId) cancelAnimationFrame(this.loopId);
        this.loop();
    },

    spawnBox() {
        let x, y, dist;
        let attempts = 0;
        do {
            x = Math.random() * (width - 100) + 50;
            y = Math.random() * (height - 100) + 50;
            dist = Math.sqrt((x-this.player.x)**2 + (y-this.player.y)**2);
            attempts++;
        } while (dist < 150 && attempts < 10);
        this.boxes.push(new Box(x, y));
    },

    spawnExplosion(x, y, color, count=10) {
        for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, color));
        AudioSys.explode();
    },

    update() {
        if (!this.active) return;
        this.frame++;

        // Difficulty
        const enemyRate = Math.max(40, 180 - Math.floor(this.score / 500));
        if (this.frame % enemyRate === 0) this.enemies.push(new Enemy(this.player));
        if (this.boxes.length < 5 + Math.floor(this.score/2000) && this.frame % 100 === 0) this.spawnBox();

        // Player
        this.player.update();
        if (this.player.cooldown > 0) this.player.cooldown--;
        
        // Shooting
        if (Input.isShooting() && this.player.cooldown <= 0) {
            const tx = Input.fireTouch.active ? Input.fireTouch.x : Input.mouse.x;
            const ty = Input.fireTouch.active ? Input.fireTouch.y : Input.mouse.y;
            const angle = Math.atan2(ty - this.player.y, tx - this.player.x);
            
            this.bullets.push(new Bullet(this.player.x, this.player.y, angle));
            if (this.player.weaponLevel >= 2) {
                this.bullets.push(new Bullet(this.player.x, this.player.y, angle - 0.2));
                this.bullets.push(new Bullet(this.player.x, this.player.y, angle + 0.2));
            }
            
            this.player.cooldown = 10;
            AudioSys.shoot();
        }

        // Updates
        this.bullets.forEach(e => e.update());
        this.enemies.forEach(e => e.update());
        this.boxes.forEach(e => e.update());
        this.particles.forEach(e => e.update());

        // Collisions: Bullets
        for (let i = this.bullets.length-1; i>=0; i--) {
            const b = this.bullets[i];
            
            // Vs Boxes
            for (let j = this.boxes.length-1; j>=0; j--) {
                const box = this.boxes[j];
                // Simple AABB vs Point + radius collision
                if (b.x > box.x && b.x < box.x+box.w && b.y > box.y && b.y < box.y+box.h) {
                    b.dead = true;
                    box.hp--;
                    AudioSys.hit();
                    this.spawnExplosion(b.x, b.y, box.color, 3);
                    
                    if (box.hp <= 0) {
                        box.dead = true;
                        this.score += (box.type === 'puzzle' ? 200 : 50);
                        this.spawnExplosion(box.x+box.w/2, box.y+box.h/2, box.color, 15);
                        
                        // Powerup Chance
                        if(Math.random() < 0.1) {
                            this.player.hp = Math.min(100, this.player.hp + 20);
                            AudioSys.powerup();
                        }
                        if(Math.random() < 0.05) {
                             this.player.weaponLevel = 3; 
                             this.player.weaponTimer = 300; 
                             AudioSys.powerup();
                        }

                        // Chain Reaction
                        if (box.type === 'puzzle') {
                             this.enemies.forEach(en => {
                                 if (Math.hypot(en.x - b.x, en.y - b.y) < 300) {
                                     en.dead = true;
                                     this.spawnExplosion(en.x, en.y, '#f00', 10);
                                     this.score += 50;
                                 }
                             });
                        }
                    }
                }
            }
            
            // Vs Enemies
            for (let k = this.enemies.length-1; k>=0; k--) {
                const e = this.enemies[k];
                if (Math.hypot(e.x - b.x, e.y - b.y) < e.r + b.r) {
                    b.dead = true;
                    e.dead = true;
                    this.score += 100;
                    AudioSys.hit();
                    this.spawnExplosion(e.x, e.y, '#f00', 8);
                }
            }
        }

        // Enemies vs Player
        for (let e of this.enemies) {
            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < e.r + this.player.r) {
                e.dead = true;
                this.player.hp -= 20;
                this.spawnExplosion(this.player.x, this.player.y, '#f00', 10);
                AudioSys.explode();
                if (navigator.vibrate) navigator.vibrate(100);
            }
        }

        // Cleanup
        this.bullets = this.bullets.filter(b => !b.dead);
        this.enemies = this.enemies.filter(e => !e.dead);
        this.boxes = this.boxes.filter(b => !b.dead);
        this.particles = this.particles.filter(p => !p.dead);

        // UI
        document.getElementById('scoreDisplay').innerText = this.score.toString().padStart(6, '0');
        document.getElementById('hpBar').style.width = this.player.hp + '%';

        if (this.player.hp <= 0) this.gameOver();
    },

    draw() {
        // Clear
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, width, height);

        // Additive blending for Neon effect (very fast on mobile compared to shadowBlur)
        ctx.globalCompositeOperation = 'lighter';

        // Dynamic Grid
        ctx.strokeStyle = 'rgba(0, 243, 255, 0.08)';
        ctx.lineWidth = 1;
        const offset = (this.frame * 0.5) % 50;
        for (let x=0; x<width; x+=50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, height); ctx.stroke(); }
        for (let y=offset; y<height; y+=50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }

        // Draw Game Objects
        this.boxes.forEach(b => b.draw(ctx));
        this.particles.forEach(p => p.draw(ctx));
        this.enemies.forEach(e => e.draw(ctx));
        this.bullets.forEach(b => b.draw(ctx));
        if (this.active) this.player.draw(ctx);

        // Virtual Joystick (Visuals)
        if (Input.stick.active) {
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(Input.stick.startX, Input.stick.startY, 40, 0, Math.PI*2);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0,243,255,0.5)';
            ctx.beginPath();
            ctx.arc(Input.stick.currX, Input.stick.currY, 15, 0, Math.PI*2);
            ctx.fill();
        }

        // Fire Touch Visual
        if (Input.fireTouch.active) {
            ctx.strokeStyle = 'rgba(255,0,255,0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(Input.fireTouch.x, Input.fireTouch.y, 30, 0, Math.PI*2);
            ctx.stroke();
        }

        ctx.globalCompositeOperation = 'source-over';
    },

    loop() {
        this.update();
        this.draw();
        this.loopId = requestAnimationFrame(() => this.loop());
    },

    gameOver() {
        this.active = false;
        document.getElementById('menu-layer').classList.remove('hidden');
        document.getElementById('gameOverMenu').classList.remove('hidden');
        document.getElementById('finalScoreMsg').innerText = `SYSTEM FAILURE // SCORE: ${this.score}`;
        this.updateLeaderboard(this.score);
    },

    updateLeaderboard(newScore) {
        let scores = JSON.parse(localStorage.getItem('neon_scores') || '[]');
        if (newScore > 0) scores.push({d: new Date().toLocaleDateString(), s: newScore});
        scores.sort((a, b) => b.s - a.s);
        scores = scores.slice(0, 5);
        localStorage.setItem('neon_scores', JSON.stringify(scores));
        
        const div = document.getElementById('lbContent');
        div.innerHTML = '';
        if(scores.length === 0) div.innerHTML = '<p>No Records Found</p>';
        scores.forEach((sc, i) => {
            div.innerHTML += `<div class="lb-row"><span>#${i+1}</span><span>${sc.s}</span></div>`;
        });
    }
};

// Initial leaderboard render
Game.updateLeaderboard(0);

</script>
</body>
</html>
